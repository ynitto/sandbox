# Phase 4: スプリントプランニング

**前提確認**: `plan.json` が存在し、`current_phase >= 3` であること。`plan.json` が存在しない場合は Phase 2 から再開する。

バックログからスプリントに含めるタスクを選出し、並列実行グループ（ウェーブ）に分割する。

## 手順

1. 直前スプリントの `process_review` と `next_sprint_actions` を確認し、今回のプランに反映する
2. priority順にタスクを並べる
3. depends_onの制約を考慮し、先行タスクが未完了のタスクは選出しない
4. 1スプリント = 3〜5タスクを目安にする
5. **ウェーブ分割**: 選出したタスクを依存関係に基づいて実行グループ（ウェーブ）に分割する:
   - **Wave 1**: スプリント内に先行依存がないタスク（depends_onが空、または依存先がすべて前スプリントまでに完了済み）
   - **Wave 2**: Wave 1 のタスクに依存するタスク
   - **Wave N**: Wave N-1 のタスクに依存するタスク
   - 同一ウェーブ内のタスクは**並列実行**される
   - **同一ファイル競合の対処**: 同一ウェーブ内のタスクが同一ファイルを変更する可能性がある場合、以下の2つの戦略から選択する:
     - **戦略A: ウェーブ分割（デフォルト）** — 変更箇所が密接に絡み合う場合（同一関数・同一ブロック）、変更範囲が事前に特定しにくい場合、または判断に迷う場合はウェーブを分けて直列化する
     - **戦略B: git worktree 並列実行** — 変更箇所が同一ファイルでも独立したセクション（例: 別々の関数やクラスの追加）であることが明確な場合は、テンプレート「worktree 並列実行時」を参照してサブエージェントを分離した worktree で並列実行し、完了後にマージする。マージコンフリクトが発生した場合はユーザーに報告して手動解決を依頼する
6. プランJSONを生成する（`execution_groups` フィールドにウェーブを記録）
7. バリデーションを実行する（**最大3回**。3回失敗したらエラー内容をユーザーに提示して修正方針を相談する。`plan.json` と `skills.json` はどちらも作業ディレクトリのルートに配置する）:
   ```bash
   python .github/skills/scrum-master/scripts/validate_plan.py plan.json --skills-json skills.json
   ```
8. プランをユーザーに表形式で提示して承認を得る（ウェーブと並列実行の情報を含め、反映した改善点も1〜3件で併記）:
   ```
   **Sprint N プラン**

   | Wave | # | タスク | スキル | 依存 |
   |------|---|--------|--------|------|
   | 1 | b1 | [action] | [skill] | - |
   | 1 | b2 | [action] | [skill] | - |
   | 2 | b3 | [action] | [skill] | b1 |
   | 2 | b4 | [action] | - | b2 |
   | 3 | b5 | [action] | [skill] | b3, b4 |

   並列実行: Wave 1 (2件同時) → Wave 2 (2件同時) → Wave 3 (1件)

   今回反映した改善点:
   - [next_sprint_action 1]
   - [next_sprint_action 2]

   このプランで進めますか？
   ```
