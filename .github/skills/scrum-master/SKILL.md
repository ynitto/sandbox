---
name: scrum-master
description: ユーザーのプロンプトをタスク分解し、サブエージェントにスキルを委譲してスプリント単位で実行するオーケストレーター。「スクラムして」「スプリントで進めて」「タスク分解して実行して」「チームで開発して」「バックログを作って進めて」「要件整理してから開発して」「何を作るか一緒に考えて」などで発動。曖昧な指示は要件定義フェーズで対話しながら明確化する。スキル不足時はskill-creatorで作成し、git-skill-managerでリポジトリ共有も可能。
metadata:
  version: "1.0"
---

# scrum-master

ユーザーのプロンプトをバックログに分解し、スプリント単位でサブエージェントに委譲して実行するオーケストレーター。

## 実行ループ

以下のフェーズを順に実行する。フェーズを遷移するたびにプランJSONの `current_phase` を更新すること。これにより会話が長くなっても現在地を見失わない。

### Phase 1: スキル探索

利用可能なスキルを把握する。

```bash
python .github/skills/scrum-master/scripts/discover_skills.py .github/skills --registry ~/.copilot/skill-registry.json
```

`--registry` を指定すると、無効化されたスキルやアクティブプロファイル外のスキルが除外される。レジストリが存在しない場合は全スキルが返される。

出力されたJSON一覧を記憶する。以降のタスク分解でスキルマッチングに使う。

### Phase 2: バックログ作成

ユーザーのプロンプトからバックログを作成する。曖昧な指示の場合は requirements-definer を介して要件を明確化してからバックログに変換する。

#### Step 2-0: requirements.json の存在チェック

作業ディレクトリのルートに `requirements.json` が存在するか確認する。

- **存在する** → Step 2-3（requirements.json → バックログ変換）へスキップする
- **存在しない** → Step 2-1（曖昧度判定）へ進む

#### Step 2-1: 曖昧度判定

ユーザーのプロンプトを以下の4項目で評価する:

| # | 判定項目 | 明確の例 | 曖昧の例 |
|---|----------|---------|---------|
| a | ゴールが1文で定義可能か | 「REST APIにページネーションを実装して」 | 「ECサイト作って」 |
| b | 対象ユーザー/利用シーンが特定できるか | 「管理者画面のダッシュボード」 | 「Webアプリで」 |
| c | スコープ（In/Out）が推定可能か | 「src/api/users.tsに追加」 | 「いい感じに」 |
| d | 3タスク以内で分解可能か | 「バリデーションを追加してテストを書いて」 | 機能数が不明 |

**判定ルール:**

- **4項目すべて明確** → Step 2-4（従来の直接バックログ作成）へ
- **1〜3項目が不明確** → Step 2-2（requirements-definer 呼び出し）へ
- **判断に迷う場合** → ユーザーに選択肢を提示する:
  ```
  プロンプトの内容を確認しました。

  選択肢:
  1. 要件を整理してから進める（対話で要件を明確化します）
  2. このまま進める（現在の情報でバックログを作成します）
  ```

#### Step 2-2: requirements-definer 呼び出し

サブエージェントを起動する（テンプレート「requirements-definer 呼び出し時」を使用）。

完了後、`requirements.json` が生成される。Step 2-3 へ進む。

#### Step 2-3: requirements.json → バックログ変換

`requirements.json` を読み込み、以下のマッピングルールで `plan.json` のバックログに変換する:

| requirements.json | plan.json | 変換ルール |
|---|---|---|
| `goal` | `goal` | そのまま転記 |
| `functional_requirements[].user_story` or `description` | `backlog[].action` | ストーリーまたは説明から具体的な作業内容を導出 |
| `functional_requirements[].acceptance_criteria` | `backlog[].done_criteria` | Given/When/Then を検証可能な完了条件に変換 |
| `functional_requirements[].moscow` or 出現順 | `backlog[].priority` | must=1, should=2, could=3。moscow がなければ出現順 |
| `non_functional_requirements` | 横断タスクまたは制約 | パフォーマンス要件 → 専用タスク、それ以外 → 各タスクの done_criteria に制約として付与 |
| `scope.out` | バックログに含めない | 除外スコープとして記録（変換しない） |

**変換の粒度:**
- 1つの functional_requirement が複数タスクに分解されることがある（1タスク = 1スキルの1回の実行）
- acceptance_criteria が複数ある場合、同一タスクの done_criteria に統合するか、テスト用の別タスクに分離する

変換後、Step 2-5 へ進む。

#### Step 2-4: 従来のバックログ作成

プロンプトから直接バックログを作成する（requirements-definer を経由しないパス）。

1. ゴール（最終目標）を1文で定義する
2. ゴール達成に必要な全タスクを洗い出す
3. 各タスクに以下を設定する:
   - **action**: 具体的な作業内容
   - **priority**: 実行優先度（1が最高）
   - **done_criteria**: 完了の定義
   - **skill**: Phase 1のスキル一覧からマッチするスキル名。該当なしはnull
   - **depends_on**: 先行タスクのID

Step 2-5 へ進む。

#### Step 2-5: プランJSON保存

スキーマ詳細は [references/plan-schema.md](references/plan-schema.md) を参照する。プランJSONは **作業ディレクトリのルートに `plan.json` として保存する**。

**プランJSON最小スケルトン（この形式で生成すること）:**
```json
{
  "current_phase": 2,
  "goal": "...",
  "requirements_source": "direct",
  "backlog": [
    {"id": "b1", "action": "...", "priority": 1, "done_criteria": "...", "skill": "...", "depends_on": [], "status": "pending", "result": null}
  ],
  "sprints": [],
  "velocity": {"completed_per_sprint": [], "remaining": 0}
}
```

- `requirements_source`: バックログの出自を記録する。値は `"requirements-definer"`（requirements.json 経由）または `"direct"`（プロンプトから直接作成）のいずれか

**タスク分解の粒度:**
- 1タスク = 1スキルの1回の実行
- 「AしてBする」は2タスクに分ける
- 汎用タスク（skill: null）は判断・調査・確認など、スキル不要な軽微な作業に限定する

### Phase 3: スキルギャップ解決

バックログを精査し、スキルの新規作成・改良が必要なケースを検出する。

**ガードレール**: Phase 3 内でのスキル作成/改良 → Phase 1 再実行は **最大2回** まで。超えた場合はユーザーに「残りのスキルギャップは手動で解決するか、スキルなしで進めるか」を確認する。

#### 3a: スキル不足（skill: null だがスキルが必要）

1. ユーザーに報告する:
   ```
   以下のタスクに対応するスキルがありません:
   - [タスク内容]

   選択肢:
   1. 新しいスキルを作成する（skill-creatorを使用）
   2. 既存コードベースからスキルを生成する（codebase-to-skillを使用）
   3. 外部URLからスキルを取り込む（skill-recruiterを使用）
   4. スキルなしで実行を試みる
   5. このタスクをスキップする
   ```
2. ユーザーが「作成する」を選んだ場合:
   - サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「スキル作成時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを新スキル名で更新する
3. ユーザーが「コードベースから生成する」を選んだ場合:
   - 対象コードベースのパスをユーザーに確認する
   - サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「コードベースからスキル生成時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを新スキル名で更新する
4. ユーザーが「外部URLから取り込む」を選んだ場合:
   - スキルのGitリポジトリURLをユーザーに確認する
   - サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「スキル招募時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを新スキル名で更新する

#### 3b: 既存スキルの改良（機能追加・改善・分割を含む）

タスクに割り当てたスキルが要件を十分に満たさない場合（機能不足・手順の改善・責務が広すぎて分割が必要等）:

1. ユーザーに報告する:
   ```
   スキル [skill-name] は存在しますが、改良が必要です:
   - [不足点・改善点・分割の必要性]

   選択肢:
   1. スキルを改良してから実行する（skill-creatorを使用）
   2. 既存コードベースを分析してスキルを補強する（codebase-to-skillを使用）
   3. 現状のスキルのまま実行を試みる
   4. このタスクをスキップする
   ```
2. ユーザーが「改良する」を選んだ場合:
   - サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「スキル改良時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - 分割により新スキルが生まれた場合、バックログ内の旧スキル参照を新スキル名で更新する
3. ユーザーが「コードベースから補強する」を選んだ場合:
   - 参考にするコードベースのパスをユーザーに確認する
   - サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「コードベースからスキル生成時」を使用。既存スキルの改良である旨と不足点を併せて渡す）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを更新後のスキル名で更新する

### Phase 4: スプリントプランニング

バックログからスプリントに含めるタスクを選出し、並列実行グループ（ウェーブ）に分割する。

1. 直前スプリントの `process_review` と `next_sprint_actions` を確認し、今回のプランに反映する
2. priority順にタスクを並べる
3. depends_onの制約を考慮し、先行タスクが未完了のタスクは選出しない
4. 1スプリント = 3〜5タスクを目安にする
5. **ウェーブ分割**: 選出したタスクを依存関係に基づいて実行グループ（ウェーブ）に分割する:
   - **Wave 1**: スプリント内に先行依存がないタスク（depends_onが空、または依存先がすべて前スプリントまでに完了済み）
   - **Wave 2**: Wave 1 のタスクに依存するタスク
   - **Wave N**: Wave N-1 のタスクに依存するタスク
   - 同一ウェーブ内のタスクは**並列実行**される
   - **同一ファイル競合の対処**: 同一ウェーブ内のタスクが同一ファイルを変更する可能性がある場合、以下の2つの戦略から選択する:
     - **戦略A: ウェーブ分割（デフォルト）** — 変更箇所が密接に絡み合う場合（同一関数・同一ブロック）、変更範囲が事前に特定しにくい場合、または判断に迷う場合はウェーブを分けて直列化する
     - **戦略B: git worktree 並列実行** — 変更箇所が同一ファイルでも独立したセクション（例: 別々の関数やクラスの追加）であることが明確な場合は、テンプレート「worktree 並列実行時」を参照してサブエージェントを分離した worktree で並列実行し、完了後にマージする。マージコンフリクトが発生した場合はユーザーに報告して手動解決を依頼する
6. プランJSONを生成する（`execution_groups` フィールドにウェーブを記録）
7. バリデーションを実行する（**最大3回**。3回失敗したらエラー内容をユーザーに提示して修正方針を相談する。`plan.json` と `skills.json` はどちらも作業ディレクトリのルートに配置する）:
   ```bash
   python .github/skills/scrum-master/scripts/validate_plan.py plan.json --skills-json skills.json
   ```
8. プランをユーザーに表形式で提示して承認を得る（ウェーブと並列実行の情報を含め、反映した改善点も1〜3件で併記）:
   ```
   **Sprint N プラン**

   | Wave | # | タスク | スキル | 依存 |
   |------|---|--------|--------|------|
   | 1 | b1 | [action] | [skill] | - |
   | 1 | b2 | [action] | [skill] | - |
   | 2 | b3 | [action] | [skill] | b1 |
   | 2 | b4 | [action] | - | b2 |
   | 3 | b5 | [action] | [skill] | b3, b4 |

   並列実行: Wave 1 (2件同時) → Wave 2 (2件同時) → Wave 3 (1件)

   今回反映した改善点:
   - [next_sprint_action 1]
   - [next_sprint_action 2]

   このプランで進めますか？
   ```

### Phase 5: タスク実行

スプリント内のタスクをウェーブ単位で実行する。同一ウェーブ内のタスクは並列にサブエージェントへ委譲し、ウェーブ間は直列で進行する。

#### 実行フロー

```
Wave 1: [b1, b2] → 並列実行 → 全完了を待機
         ↓
Wave 2: [b3, b4] → 並列実行 → 全完了を待機
         ↓
Wave 3: [b5]     → 単独実行
```

#### 手順

`execution_groups` の各ウェーブを順に処理する:

1. **ウェーブ開始**: ウェーブ内の全タスクのstatusを `in_progress` に更新する
2. **並列起動**: ウェーブ内の全タスクについてサブエージェントを**同時に**起動する（Claude Code: Task ツールを複数同時呼び出し / GitHub Copilot: `#tool:agent/runSubagent` を複数同時呼び出し）
   - **skill指定ありの場合** は該当スキルの SKILL.md をサブエージェントに読み込ませる
   - **skill: null の場合** は該当スキルを指定しない。skill: null で許可する作業は「情報の調査・確認」「ユーザーへの判断依頼」「ファイルの読み取り・軽微な編集」に限定する
   - タスクのactionとコンテキスト（先行タスクのresult）をプロンプトとして渡す
   - **注意**: ウェーブ1ではコンテキストは前スプリントの結果のみ。ウェーブ2以降は前ウェーブの結果をコンテキストに含める
3. **結果収集**: 全サブエージェントの完了を待ち、各タスクのresultフィールドに結果を記録する
4. **完了判定**: 各タスクのdone_criteriaに照らして判定する:
   - 満たす → status: `completed`
   - 満たさない → status: `failed`、理由をresultに記録
5. **ウェーブ内失敗時の判断**:
   - 失敗タスクに後続ウェーブのタスクが依存している場合 → ユーザーに報告する（下記テンプレート）
   - 失敗タスクに依存するタスクがない場合 → 報告のみで次のウェーブへ進む
6. **次のウェーブへ**: 前ウェーブの結果を踏まえて次ウェーブを実行する。依存先が失敗したタスクはスキップする（status: `skipped`）

**並列実行の制約**:
- 同一ファイルを編集するタスクが同一ウェーブに含まれる場合、コンフリクト防止のためウェーブを分割する（Phase 4 で考慮すること）
- ユーザーへの対話的な確認が必要なタスク（skill: null）は単独ウェーブに分離することを推奨する

**タスク失敗時の報告テンプレート**:
   ```
   Wave [N] 実行結果:
   - [id]: 完了 ✓
   - [id]: 失敗 ✗ — [理由]

   失敗タスクに依存する後続タスク: [ids]

   選択肢:
   1. 失敗タスクをリトライする（後続タスクは待機）
   2. 失敗タスクをスキップし、依存タスクもスキップする
   3. スプリントを中断する
   ```

### Phase 6: スプリントレビュー & レトロスペクティブ

スプリント内の全タスク完了後（またはユーザーが中断を選択後）、レビュー・フィードバック収集・スキル評価を順に行う。

1. サブエージェントを起動する（テンプレート「スプリントレビュー時」を使用）
2. sprint-reviewer が出力したテキストをパースしてプランJSONに格納する:
   - `レビュー:` → sprintsの `review` フィールド（ゴール進捗評価）
   - `進め方レビュー:` → sprintsの `process_review` フィールド
   - `レトロスペクティブ:` → sprintsの `retro` フィールド
   - `次スプリント反映アクション:` → sprintsの `next_sprint_actions` フィールド（配列）
   - `ブロッカー:` → sprintsの `impediments` フィールド（「なし」の場合は空配列）
3. **スキルフィードバック収集**: このスプリントで実行したスキルのフィードバックを一括収集する。
   skill が指定され completed になったタスクからスキル名を重複なく抽出し、サブエージェントを起動する（テンプレート「スキルフィードバック収集時」を使用）。

4. **ワークスペーススキルの棚卸し**: サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「スキル評価時」を使用）

5. **スキル発見**: 今スプリントで新しいスキルが作成された場合に提案する:
   ```
   最近のチャット履歴から新しいスキル候補を発見できるかもしれません。
   git-skill-manager discover を実行しますか？ [y/N]
   ```
   - 「はい」: サブエージェントを起動する（Claude Code: Task ツール / GitHub Copilot: `#tool:agent/runSubagent`）（テンプレート「スキル発見時」を使用）
   - 結果をreviewフィールドに追記する

### Phase 7: 進捗レポートと継続判断

ユーザーに進捗を報告し、次のアクションを確認する。

**ガードレール**: スプリント総数は **最大5** とする。5スプリント消化後もバックログが残っている場合は、残タスクの一覧を提示し「続行 / ゴール縮小 / 完了」をユーザーに確認する。

```
**Sprint N 結果** (全体進捗: XX%)

| Wave | # | タスク | スキル | ステータス | サマリー |
|------|---|--------|--------|------------|----------|
| 1 | b1 | [action] | [skill] | 完了 | [result] |
| 1 | b2 | [action] | [skill] | 完了 | [result] |
| 2 | b3 | [action] | [skill] | 失敗 | [result] |
| 2 | b4 | [action] | - | スキップ | - |

完了: X 件 / 失敗: Y 件 / スキップ: Z 件 / バックログ残り: W 件
並列効率: [N] タスクを [M] ウェーブで実行

進め方レビュー:
- [process_review]

次スプリント反映アクション:
- [next_sprint_action 1]
- [next_sprint_action 2]

選択肢:
1. 次のスプリントへ進む
2. バックログを見直す（タスクの追加・削除・優先度変更）
3. ここで完了とする
```

- 「次スプリント」→ 前スプリントでスキルの作成・改良が行われた場合は Phase 1 を再実行してからPhase 4 に戻る。それ以外は直接 Phase 4 に戻る。Phase 4 では `next_sprint_actions` を必ず反映する
- 「バックログ見直し」→ ユーザーと対話してバックログを修正 → Phase 4 に戻る
- 「完了」→ 最終レポートを出力して終了する

## サブエージェントへの指示テンプレート

各テンプレートの詳細は [references/subagent-templates.md](references/subagent-templates.md) を参照すること。

**重要**:
- SKILL.md の内容をプロンプトに埋め込まない。ファイルパスだけ渡し、サブエージェント自身に読ませる。
- すべてのテンプレートに戻り値の形式指定を含める。

### 利用可能なテンプレート一覧

| テンプレート | 用途 |
|---|---|
| requirements-definer 呼び出し時 | 要件定義の実行 |
| skill: null タスク実行時 | スキル不要な調査・確認・軽微な編集 |
| スキル実行時 | 既存スキルを使ったタスク実行 |
| スキル作成時 | skill-creator でスキルを新規作成 |
| スキル改良時 | skill-creator でスキルを改良・分割 |
| コードベースからスキル生成時 | codebase-to-skill でスキルを生成 |
| スキル招募時 | skill-recruiter で外部スキルを取得 |
| スプリントレビュー時 | sprint-reviewer でレビューを実施 |
| スキルフィードバック収集時 | 使用スキルのフィードバックを収集・記録 |
| スキル昇格時 | git-skill-manager promote を実行 |
| スキル評価時 | skill-evaluator でスキルを評価 |
| スキル共有時 | git-skill-manager push を実行 |
| スキル発見時 | git-skill-manager discover を実行 |

<!-- テンプレート本文は references/subagent-templates.md に記載 -->
## 動作環境

- **GitHub Copilot Chat**（Windows / macOS / Linux）および **Claude Code** で動作する
- スクリプト実行は `python`（環境によっては `python3`）
- パス区切りは `/` を使用する（クロスプラットフォームで動作する）
- ファイル書き出し時の文字コードは **UTF-8 without BOM**

### サブエージェント起動ツールの環境別対応

| 環境 | サブエージェント起動方法 |
|------|------------------------|
| Claude Code | `Task` ツールを使用。`subagent_type: "general-purpose"` を指定する |
| GitHub Copilot | `#tool:agent/runSubagent` を使用する |

並列実行（同一ウェーブ）は、Claude Code では複数の Task ツール呼び出しを単一メッセージに並べることで実現する。

## エラーハンドリング

| 状況 | 対応 |
|---|---|
| discover_skills.py 実行失敗 | .github/skills/ ディレクトリの存在を確認。なければ作成を提案する |
| validate_plan.py バリデーション失敗 | エラー内容に従ってプランJSONを修正し再検証する |
| サブエージェント実行失敗 | ユーザーにリトライ/スキップ/中断の選択肢を提示する |
| 全タスク失敗 | ゴール自体の実現可能性をユーザーと再検討する |
