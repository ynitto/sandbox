---
name: scrum-master
description: ユーザーのプロンプトをタスク分解し、サブエージェントにスキルを委譲して実行するオーケストレーター。複雑なリクエスト、複数ステップの作業、「〜を作って〜して」のような複合依頼で発動する。「スクラムして」「スクラム開発して」「スプリントで進めて」「チームで開発して」「タスク分解して実行して」「バックログを作って進めて」「段階的に開発して」などのスクラム・チーム開発系のリクエストでも発動する。スプリント制で段階的に実行し、各スプリント完了時にユーザーに確認する。スキルが足りない場合はskill-creatorでスキルを作成する。既存スキルの改良や分割もスプリント内で実行できる。作成・更新されたスキルはgit-skill-managerでリポジトリに共有できる。
---

# scrum-master

ユーザーのプロンプトをバックログに分解し、スプリント単位でサブエージェントに委譲して実行するオーケストレーター。

## 実行ループ

以下のフェーズを順に実行する。フェーズを遷移するたびにプランJSONの `current_phase` を更新すること。これにより会話が長くなっても現在地を見失わない。

### Phase 1: スキル探索

利用可能なスキルを把握する。

```bash
python .github/skills/scrum-master/scripts/discover_skills.py .github/skills --registry %USERPROFILE%\.copilot\skill-registry.json
```

`--registry` を指定すると、無効化されたスキルやアクティブプロファイル外のスキルが除外される。レジストリが存在しない場合は全スキルが返される。

出力されたJSON一覧を記憶する。以降のタスク分解でスキルマッチングに使う。

### Phase 2: バックログ作成

ユーザーのプロンプトからバックログを作成する。

1. ゴール（最終目標）を1文で定義する
2. ゴール達成に必要な全タスクを洗い出す
3. 各タスクに以下を設定する:
   - **action**: 具体的な作業内容
   - **priority**: 実行優先度（1が最高）
   - **done_criteria**: 完了の定義
   - **skill**: Phase 1のスキル一覧からマッチするスキル名。該当なしはnull
   - **depends_on**: 先行タスクのID
4. スキーマ詳細は [references/plan-schema.md](references/plan-schema.md) を参照する

**プランJSON最小スケルトン（この形式で生成すること）:**
```json
{
  "current_phase": 2,
  "goal": "...",
  "backlog": [
    {"id": "b1", "action": "...", "priority": 1, "done_criteria": "...", "skill": "...", "depends_on": [], "status": "pending", "result": null}
  ],
  "sprints": [],
  "velocity": {"completed_per_sprint": [], "remaining": 0}
}
```

**タスク分解の粒度:**
- 1タスク = 1スキルの1回の実行
- 「AしてBする」は2タスクに分ける
- 汎用タスク（skill: null）は判断・調査・確認など、スキル不要な軽微な作業に限定する

### Phase 3: スキルギャップ解決

バックログを精査し、スキルの新規作成・改良が必要なケースを検出する。

**ガードレール**: Phase 3 内でのスキル作成/改良 → Phase 1 再実行は **最大2回** まで。超えた場合はユーザーに「残りのスキルギャップは手動で解決するか、スキルなしで進めるか」を確認する。

#### 3a: スキル不足（skill: null だがスキルが必要）

1. ユーザーに報告する:
   ```
   以下のタスクに対応するスキルがありません:
   - [タスク内容]

   選択肢:
   1. 新しいスキルを作成する（skill-creatorを使用）
   2. 既存コードベースからスキルを生成する（codebase-to-skillを使用）
   3. スキルなしで実行を試みる
   4. このタスクをスキップする
   ```
2. ユーザーが「作成する」を選んだ場合:
   - `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「スキル作成時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを新スキル名で更新する
3. ユーザーが「コードベースから生成する」を選んだ場合:
   - 対象コードベースのパスをユーザーに確認する
   - `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「コードベースからスキル生成時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを新スキル名で更新する

#### 3b: 既存スキルの改良（機能追加・改善・分割を含む）

タスクに割り当てたスキルが要件を十分に満たさない場合（機能不足・手順の改善・責務が広すぎて分割が必要等）:

1. ユーザーに報告する:
   ```
   スキル [skill-name] は存在しますが、改良が必要です:
   - [不足点・改善点・分割の必要性]

   選択肢:
   1. スキルを改良してから実行する（skill-creatorを使用）
   2. 既存コードベースを分析してスキルを補強する（codebase-to-skillを使用）
   3. 現状のスキルのまま実行を試みる
   4. このタスクをスキップする
   ```
2. ユーザーが「改良する」を選んだ場合:
   - `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「スキル改良時」を使用）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - 分割により新スキルが生まれた場合、バックログ内の旧スキル参照を新スキル名で更新する
3. ユーザーが「コードベースから補強する」を選んだ場合:
   - 参考にするコードベースのパスをユーザーに確認する
   - `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「コードベースからスキル生成時」を使用。既存スキルの改良である旨と不足点を併せて渡す）
   - 完了後、Phase 1を再実行してスキル一覧を更新する
   - バックログのskillフィールドを更新後のスキル名で更新する

### Phase 4: スプリントプランニング

バックログからスプリントに含めるタスクを選出し、並列実行グループ（ウェーブ）に分割する。

1. 直前スプリントの `process_review` と `next_sprint_actions` を確認し、今回のプランに反映する
2. priority順にタスクを並べる
3. depends_onの制約を考慮し、先行タスクが未完了のタスクは選出しない
4. 1スプリント = 3〜5タスクを目安にする
5. **ウェーブ分割**: 選出したタスクを依存関係に基づいて実行グループ（ウェーブ）に分割する:
   - **Wave 1**: スプリント内に先行依存がないタスク（depends_onが空、または依存先がすべて前スプリントまでに完了済み）
   - **Wave 2**: Wave 1 のタスクに依存するタスク
   - **Wave N**: Wave N-1 のタスクに依存するタスク
   - 同一ウェーブ内のタスクは**並列実行**される
6. プランJSONを生成する（`execution_groups` フィールドにウェーブを記録）
7. バリデーションを実行する（**最大3回**。3回失敗したらエラー内容をユーザーに提示して修正方針を相談する）:
   ```bash
   python .github/skills/scrum-master/scripts/validate_plan.py plan.json --skills-json skills.json
   ```
8. プランをユーザーに表形式で提示して承認を得る（ウェーブと並列実行の情報を含め、反映した改善点も1〜3件で併記）:
   ```
   **Sprint N プラン**

   | Wave | # | タスク | スキル | 依存 |
   |------|---|--------|--------|------|
   | 1 | b1 | [action] | [skill] | - |
   | 1 | b2 | [action] | [skill] | - |
   | 2 | b3 | [action] | [skill] | b1 |
   | 2 | b4 | [action] | - | b2 |
   | 3 | b5 | [action] | [skill] | b3, b4 |

   並列実行: Wave 1 (2件同時) → Wave 2 (2件同時) → Wave 3 (1件)

   今回反映した改善点:
   - [next_sprint_action 1]
   - [next_sprint_action 2]

   このプランで進めますか？
   ```

### Phase 5: タスク実行

スプリント内のタスクをウェーブ単位で実行する。同一ウェーブ内のタスクは並列にサブエージェントへ委譲し、ウェーブ間は直列で進行する。

#### 実行フロー

```
Wave 1: [b1, b2] → 並列実行 → 全完了を待機
         ↓
Wave 2: [b3, b4] → 並列実行 → 全完了を待機
         ↓
Wave 3: [b5]     → 単独実行
```

#### 手順

`execution_groups` の各ウェーブを順に処理する:

1. **ウェーブ開始**: ウェーブ内の全タスクのstatusを `in_progress` に更新する
2. **並列起動**: ウェーブ内の全タスクについて `#tool:agent/runSubagent` を**同時に**起動する
   - **skill指定ありの場合** は該当スキルの SKILL.md をサブエージェントに読み込ませる
   - **skill: null の場合** は該当スキルを指定しない。skill: null で許可する作業は「情報の調査・確認」「ユーザーへの判断依頼」「ファイルの読み取り・軽微な編集」に限定する
   - タスクのactionとコンテキスト（先行タスクのresult）をプロンプトとして渡す
   - **注意**: ウェーブ1ではコンテキストは前スプリントの結果のみ。ウェーブ2以降は前ウェーブの結果をコンテキストに含める
3. **結果収集**: 全サブエージェントの完了を待ち、各タスクのresultフィールドに結果を記録する
4. **完了判定**: 各タスクのdone_criteriaに照らして判定する:
   - 満たす → status: `completed`
   - 満たさない → status: `failed`、理由をresultに記録
5. **ウェーブ内失敗時の判断**:
   - 失敗タスクに後続ウェーブのタスクが依存している場合 → ユーザーに報告する（下記テンプレート）
   - 失敗タスクに依存するタスクがない場合 → 報告のみで次のウェーブへ進む
6. **次のウェーブへ**: 前ウェーブの結果を踏まえて次ウェーブを実行する。依存先が失敗したタスクはスキップする（status: `skipped`）

**並列実行の制約**:
- 同一ファイルを編集するタスクが同一ウェーブに含まれる場合、コンフリクト防止のためウェーブを分割する（Phase 4 で考慮すること）
- ユーザーへの対話的な確認が必要なタスク（skill: null）は単独ウェーブに分離することを推奨する

**タスク失敗時の報告テンプレート**:
   ```
   Wave [N] 実行結果:
   - [id]: 完了 ✓
   - [id]: 失敗 ✗ — [理由]

   失敗タスクに依存する後続タスク: [ids]

   選択肢:
   1. 失敗タスクをリトライする（後続タスクは待機）
   2. 失敗タスクをスキップし、依存タスクもスキップする
   3. スプリントを中断する
   ```

### Phase 6: スプリントレビュー & レトロスペクティブ

スプリント内の全タスク完了後（またはユーザーが中断を選択後）、sprint-reviewer にレビューを委譲する。

1. サブエージェントを起動する（テンプレート「スプリントレビュー時」を使用）
2. sprint-reviewer が出力した JSON をそのままプランJSONに転記する:
   - `review`（tasks + goal_progress）→ sprintsのreviewフィールド
   - `retro`（keep/problem/try）→ sprintsのretroフィールド
   - `impediments` → sprintsのimpedimentsフィールド
3. **ワークスペーススキルの棚卸し**: 以下のコマンドで試用中スキルを評価する:
   ```bash
   python .github/skills/git-skill-manager/scripts/manage.py list-workspace-eval
   ```
   出力例:
   ```
   📋 ワークスペーススキルの評価:
     skill-A   ok:3 問題:0  → ✅ 昇格推奨
     skill-B   ok:1 問題:1  → ⚠️  要改良後昇格
     skill-C   ok:1 問題:0  → 🔄 試用継続
   ```
   ユーザーに提示して次のアクションを選んでもらう:
   ```
   ワークスペーススキルの状況です。
   昇格推奨: skill-A → 昇格しますか？（git-skill-manager promote）
   要改良:   skill-B → 改良しますか？（git-skill-manager refine）
   ```
   - 「昇格する」: `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「スキル昇格時」を使用）
   - 「改良する」: `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「スキル改良時」を使用）

4. **スキル発見**: `skill_discovery.last_run_at` から 7日以上経過している場合、または今スプリントで新しいスキルが作成された場合に提案する:
   ```
   最近のチャット履歴から新しいスキル候補を発見できるかもしれません。
   git-skill-manager discover を実行しますか？ [y/N]
   ```
   - 「はい」: `#tool:agent/runSubagent` を使ってサブエージェントを起動する（テンプレート「スキル発見時」を使用）
   - 結果をreviewフィールドに追記する

### Phase 7: 進捗レポートと継続判断

ユーザーに進捗を報告し、次のアクションを確認する。

**ガードレール**: スプリント総数は **最大5** とする。5スプリント消化後もバックログが残っている場合は、残タスクの一覧を提示し「続行 / ゴール縮小 / 完了」をユーザーに確認する。

```
**Sprint N 結果** (全体進捗: XX%)

| Wave | # | タスク | スキル | ステータス | サマリー |
|------|---|--------|--------|------------|----------|
| 1 | b1 | [action] | [skill] | 完了 | [result] |
| 1 | b2 | [action] | [skill] | 完了 | [result] |
| 2 | b3 | [action] | [skill] | 失敗 | [result] |
| 2 | b4 | [action] | - | スキップ | - |

完了: X 件 / 失敗: Y 件 / スキップ: Z 件 / バックログ残り: W 件
並列効率: [N] タスクを [M] ウェーブで実行

進め方レビュー:
- [process_review]

次スプリント反映アクション:
- [next_sprint_action 1]
- [next_sprint_action 2]

選択肢:
1. 次のスプリントへ進む
2. バックログを見直す（タスクの追加・削除・優先度変更）
3. ここで完了とする
```

- 「次スプリント」→ 前スプリントでスキルの作成・改良が行われた場合は Phase 1 を再実行してからPhase 4 に戻る。それ以外は直接 Phase 4 に戻る。Phase 4 では `next_sprint_actions` を必ず反映する
- 「バックログ見直し」→ ユーザーと対話してバックログを修正 → Phase 4 に戻る
- 「完了」→ 最終レポートを出力して終了する

## サブエージェントへの指示テンプレート

**重要**:
- SKILL.md の内容をプロンプトに埋め込まない。ファイルパスだけ渡し、サブエージェント自身に読ませる。これによりプロンプトを短く保ち、安定性を確保する。
- すべてのテンプレートに戻り値の形式指定を含める。これによりscrum-masterが結果を確実にパースできる。

### スキル実行時

```
[skill-name] スキルを実行する。

手順: [skill-md-path] を読んで手順に従ってください。
タスク: [action]
コンテキスト: [先行タスクのresultを1〜2行で要約]
完了基準: [done_criteria]

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
サマリー: [1〜2文で結果を説明]
```

### スキル作成時

```
skill-creator スキルで新しいスキルを作成する。

手順: まず .github/skills/skill-creator/SKILL.md を読んで手順に従ってください。
作成するスキル: [概要]
配置先: .github/skills/
ユーザーに要件を確認しながら進めること。

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
作成されたスキル名: [name]
サマリー: [1〜2文で結果を説明]
```

### スキル改良時

```
skill-creator スキルで既存スキルを改良する。

手順: まず .github/skills/skill-creator/SKILL.md を読んで手順に従ってください。
対象スキル: [skill-md-path]
改良内容: [改善点・追加機能・分割方針の説明]
配置先: .github/skills/
分割する場合は、元スキルの機能が漏れなく引き継がれることを確認すること。
ユーザーに改良方針を確認しながら進めること。

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
変更されたスキル名: [name(s)]
サマリー: [1〜2文で結果を説明]
```

### コードベースからスキル生成時

```
codebase-to-skill スキルで既存コードベースからスキルを生成する。

手順: まず .github/skills/codebase-to-skill/SKILL.md を読んで手順に従ってください。
対象コードベース: [codebase-path]
生成するスキルの用途: [タスクのactionと不足しているスキルの概要]
配置先: .github/skills/
既存スキルの改良の場合: [既存スキルのパスと不足点。新規作成の場合は「なし」]
ユーザーにスコープとフォーカスを確認しながら進めること。

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
作成されたスキル名: [name]
サマリー: [1〜2文で結果を説明]
```

### スプリントレビュー時

```
sprint-reviewer スキルでスプリントのレビューとレトロスペクティブを実施する。

手順: まず .github/skills/sprint-reviewer/SKILL.md を読んで手順に従ってください。
ゴール: [goal]
スプリント番号: [N]
スプリント計画:
- [計画時に選択したタスクと優先度の要約]
実行ログサマリー:
- [予定どおり進んだ点 / 遅延・失敗が出た点]
タスク一覧:
- [task-id]: action=[action], done_criteria=[done_criteria], status=[status], result=[result]
- ...

結果を以下の形式で返してください:
レビュー: [ゴール進捗の評価 1〜2文]
進め方レビュー: [スプリントプランと実行プロセスの評価 1〜2文]
レトロスペクティブ: [改善点 1〜2文]
次スプリント反映アクション:
- [改善アクション1]
- [改善アクション2]
ブロッカー: [あれば列挙、なければ「なし」]
```

### スキル昇格時

```
git-skill-manager スキルでワークスペーススキルをユーザー領域に昇格する。

手順: まず .github/skills/git-skill-manager/SKILL.md を読んで promote 操作の手順に従ってください。
対象スキル: [skill-name]
操作: promote
補足: .github/skills/[skill-name]/ を ~/.copilot/skills/ にコピーし、
      書き込み可能なリポジトリがあれば push も提案してください。

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
昇格先: [~/.copilot/skills/<name>]
push先: [repo-name または「なし」]
サマリー: [1〜2文で結果を説明]
```

### スキル共有時

```
git-skill-manager スキルでスキルをリポジトリに共有する。

手順: まず .github/skills/git-skill-manager/SKILL.md を読んで手順に従ってください。
対象スキル: [skill-path]
操作: push
リポジトリ: [repo-name]

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
サマリー: [1〜2文で結果を説明]
```

### スキル発見時

```
git-skill-manager スキルの discover 操作で、チャット履歴から新しいスキル候補を発見する。

手順: まず .github/skills/git-skill-manager/SKILL.md を読んで discover 操作の手順に従ってください。
操作: discover
補足: ユーザーのチャット履歴を分析し、繰り返しワークフローをスキル候補として提案してください。
      候補が見つかれば、ユーザーに選択させてから skill-creator でスキルを生成してください。

結果を以下の形式で返してください:
ステータス: 成功 / 失敗
発見されたスキル候補数: [N 件]
生成されたスキル: [name1, name2, ...（なければ「なし」）]
サマリー: [1〜2文で結果を説明]
```

## 動作環境

- **Copilot Chat on Windows** を前提とする
- スクリプト実行は `python`（`python3` ではない）
- パス区切りは `/` を使用する（PowerShellで動作する）
- ファイル書き出し時の文字コードは **UTF-8 without BOM**

## エラーハンドリング

| 状況 | 対応 |
|---|---|
| discover_skills.py 実行失敗 | .github/skills/ ディレクトリの存在を確認。なければ作成を提案する |
| validate_plan.py バリデーション失敗 | エラー内容に従ってプランJSONを修正し再検証する |
| サブエージェント実行失敗 | ユーザーにリトライ/スキップ/中断の選択肢を提示する |
| 全タスク失敗 | ゴール自体の実現可能性をユーザーと再検討する |
