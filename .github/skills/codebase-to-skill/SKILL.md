---
name: codebase-to-skill
description: 既存のプログラムやコードベースを分析し、アーキテクチャ・コーディング規約・開発ワークフローをSKILL.mdとしてマークダウン化するスキル。「このプロジェクトのアーキテクチャをスキル化して」「コードの規約をスキルにまとめて」「このリポジトリをスキルにして」「コードベースを分析してスキルを作って」などのリクエストで使用する。
metadata:
  version: "1.0"
---

# Codebase to Skill

既存コードベースを分析し、他のAIエージェントが同じ規約・パターンで開発できるようにするSKILL.mdを生成する。

## ゴール

対象コードベースの「暗黙知」を明文化し、以下を含むスキルを生成する:

1. **アーキテクチャ概要** - レイヤー構成、モジュール依存、エントリーポイント
2. **コーディング規約** - 命名、フォーマット、パターン
3. **開発ワークフロー** - ビルド、テスト、デプロイ手順
4. **ドメイン知識** - ビジネスロジック、データモデル、API設計

-----

## 分析プロセス

以下のステップを順に実行する。各ステップの出力を蓄積し、最後にSKILL.mdとして統合する。

### 重要: 推測禁止の原則

コードや設定ファイルから**確実に読み取れる事実**のみをスキルに記述する。判断に迷う場合や、コードだけでは意図が不明な場合は**必ずユーザーに確認する**。推測で埋めて先に進まない。

### ステップ1: スコープ確認

ユーザーに以下を確認する:

- **対象パス**: 分析対象のディレクトリ（デフォルト: カレントディレクトリ）
- **スキル名**: 生成するスキルの名前（デフォルト: リポジトリ名 + `-guide`）
- **フォーカス**: 全体 or 特定レイヤー（例: バックエンドのみ、フロントエンドのみ）
- **出力先**: スキルの保存先パス

### ステップ2: 構造スキャン

ディレクトリ構造を走査し、プロジェクトの骨格を把握する。

```
実行する分析:
  1. ディレクトリツリーの取得（深さ3階層まで）
  2. ファイル拡張子の集計
  3. 設定ファイルの特定（package.json, pyproject.toml, Cargo.toml, go.mod 等）
  4. エントリーポイントの特定（main, index, app, server 等）
  5. テストディレクトリの特定
  6. CI/CD設定の特定（.github/workflows, .gitlab-ci.yml 等）
```

**収集する情報:**

| 項目 | 確認先 | 確定条件 |
|---|---|---|
| 言語・ランタイム | 設定ファイル、拡張子分布 | 設定ファイルに明記されている |
| フレームワーク | 依存関係ファイル、import文 | 依存関係に含まれている |
| ビルドツール | Makefile, scripts, CI設定 | ファイルが存在する |
| パッケージマネージャ | lock ファイル | lock ファイルが存在する |
| テストフレームワーク | テストファイルのimport、設定 | 設定またはimportで確認 |
| リンター・フォーマッター | 設定ファイル（.eslintrc, ruff.toml 等） | 設定ファイルが存在する |

**ユーザー確認ポイント:** スキャン結果をユーザーに提示し、以下を確認する:
- 検出した技術スタックに誤りや漏れがないか
- 設定ファイルから読み取れなかった項目（バージョン不明、ツール不明等）の正確な情報

### ステップ3: アーキテクチャ分析

コードの構造的パターンを読み取る。

```
分析観点:
  1. レイヤー構成（例: Controller → Service → Repository）
  2. モジュール分割の方針（機能別 / レイヤー別 / ドメイン別）
  3. 依存関係の方向（import/require を追跡）
  4. 共有コード（utils, common, shared）の役割
  5. 外部連携（API呼び出し、DB接続、メッセージキュー）
  6. 状態管理パターン（グローバルstate, DI, Context 等）
```

**手順:**

1. 主要ディレクトリごとに代表ファイルを2-3個読む
2. import/require 文からモジュール間依存を把握
3. 設定ファイルからインフラ構成を把握
4. アスキーアートで依存関係図を作成

**ユーザー確認ポイント:** 作成した依存関係図をユーザーに提示し、以下を確認する:
- レイヤー構成の認識が正しいか
- 図に含まれていないモジュールや依存がないか
- モジュール分割の方針（機能別 / レイヤー別 / ドメイン別）の判断が正しいか

### ステップ4: コーディング規約の抽出

実際のコードから規約を帰納的に抽出する。推測ではなくコード事実に基づく。

```
抽出する規約:
  1. 命名規則
     - ファイル名: kebab-case / camelCase / snake_case
     - 変数・関数: camelCase / snake_case
     - クラス・型: PascalCase
     - 定数: UPPER_SNAKE_CASE
     - テストファイル: *.test.ts / *_test.go / test_*.py

  2. コード構成パターン
     - ファイルの内部構造（import順序、エクスポート方式）
     - エラーハンドリング方針（例外 / Result型 / エラーコード）
     - ログ出力パターン
     - コメント規約（JSDoc / docstring / 書かない方針）

  3. フレームワーク固有パターン
     - コンポーネント定義方式（関数 / クラス）
     - API定義方式（デコレータ / ルーター）
     - DB操作方式（ORM / クエリビルダー / 生SQL）
```

**手順:**

1. 各カテゴリで3-5ファイルをサンプリングして読む
2. 共通パターンを抽出（多数決の原則）
3. リンター・フォーマッター設定があればそちらを優先
4. 既存の CONTRIBUTING.md や .editorconfig も参照

**ユーザー確認ポイント:** 抽出した規約一覧をユーザーに提示し、以下を確認する:
- コード内でパターンが混在していた箇所について、どちらが正規の規約か
- 意図的な例外パターン（レガシーコード、外部ライブラリ由来等）があるか
- 暗黙的な規約でコードからは読み取れなかったものがあるか

### ステップ5: 開発ワークフローの把握

```
確認する内容:
  1. ビルド手順（npm run build, make, cargo build 等）
  2. テスト実行方法（ユニット / 統合 / E2E）
  3. リント・フォーマット実行方法
  4. 開発サーバー起動方法
  5. 環境変数の管理（.env.example の有無）
  6. Git運用（ブランチ戦略、コミットメッセージ規約）
  7. CI/CDパイプライン概要
```

**情報源の優先度:**

1. `package.json` の scripts / `Makefile` のターゲット
2. CI/CD設定ファイル
3. README.md / CONTRIBUTING.md
4. 実際のコミットログ（直近20件の形式を確認）

**ユーザー確認ポイント:** 把握したワークフローをユーザーに提示し、以下を確認する:
- 設定ファイルやREADMEに記載がなかった運用ルール（口頭伝承の手順等）があるか
- 記載はあるが現在は使われていない手順がないか
- 環境変数やシークレットの管理方法

### ステップ6: SKILL.md 生成

ステップ2-5で確認済みの情報のみを使い、以下のテンプレートに沿って統合する。ユーザー確認で解決しなかった不明点はスキルに含めない。

-----

## 出力テンプレート

```markdown
---
name: {project-name}-guide
description: {プロジェクト名}の開発ガイド。アーキテクチャ、コーディング規約、開発ワークフローを提供する。{プロジェクト名}のコードを変更・追加する際に使用する。
---

# {Project Name} 開発ガイド

## 概要

- **言語**: {言語} {バージョン}
- **フレームワーク**: {フレームワーク} {バージョン}
- **パッケージマネージャ**: {PM}
- **テスト**: {テストFW}

## アーキテクチャ

### ディレクトリ構成

{3階層のツリー図。各主要ディレクトリに1行コメント}

### レイヤー構成

{アスキーアートの依存関係図}

{各レイヤーの責務を1-2行で}

## コーディング規約

### 命名規則

| 対象 | 規則 | 例 |
|---|---|---|
| ファイル名 | {規則} | {実例} |
| 関数・メソッド | {規則} | {実例} |
| クラス・型 | {規則} | {実例} |
| 定数 | {規則} | {実例} |
| テストファイル | {規則} | {実例} |

### コード構成

{ファイル内構造、import順序、エクスポート方式}

### エラーハンドリング

{プロジェクトで採用しているパターン。コード例付き}

### {フレームワーク固有パターン}

{該当する場合のみ。コード例付き}

## 開発ワークフロー

### よく使うコマンド

| 操作 | コマンド |
|---|---|
| ビルド | {コマンド} |
| テスト | {コマンド} |
| リント | {コマンド} |
| 開発サーバー | {コマンド} |

### 新規コード追加時のチェックリスト

1. {規約に沿ったファイル配置}
2. {テストファイルの作成}
3. {リント・フォーマットの実行}
```

-----

## 出力ルール

- **事実ベース**: コードから読み取れる事実のみ記述する。推測が必要な場合はスキルに書かず、ユーザーに確認してから記述する
- **コード例は実プロジェクトから**: サンプルではなく実際のコードから引用する（ファイルパス付き）
- **簡潔に**: skill-creator の原則に従い、Copilotが既に知っている一般知識は省略する
- **500行以内**: SKILL.md本文は500行以内。超える場合は references/ に分割する
- **段階的開示**: 頻出パターンはSKILL.md本文に、稀なパターンは references/ に配置

## 分割の目安

| コードベース規模 | 推奨構成 |
|---|---|
| 小（〜50ファイル） | SKILL.md 1ファイルで完結 |
| 中（50-200ファイル） | SKILL.md + references/ 1-3ファイル |
| 大（200ファイル〜） | SKILL.md + references/ をドメイン別に分割 |

大規模の場合の構成例:

```
{project}-guide/
├── SKILL.md（概要・ナビゲーション・頻出パターン）
└── references/
    ├── architecture.md（詳細なレイヤー・モジュール説明）
    ├── conventions.md（全規約の網羅的リスト）
    └── {domain}.md（ドメイン固有の知識）
```

-----

## 使用例

### 基本

```
ユーザー: 「このプロジェクトのアーキテクチャをスキルにして」

Copilot:
  1. スコープ確認（対象パス、スキル名、フォーカス）
  2. 構造スキャン → 技術スタック提示 → ユーザー確認
  3. アーキテクチャ分析 → レイヤー図提示 → ユーザー確認
  4. コーディング規約抽出 → 規約一覧提示 → ユーザー確認
  5. 開発ワークフロー把握 → コマンド一覧提示 → ユーザー確認
  6. 確認済み情報のみで SKILL.md 生成 → 出力先に保存
  7. 「生成しました。確認してください」
```

### 特定レイヤーのみ

```
ユーザー: 「バックエンドAPIの規約だけスキルにして」

Copilot:
  1. フォーカスを「バックエンドAPI」に限定
  2. API関連ディレクトリのみ分析
  3. ルーティング、バリデーション、レスポンス形式の分析結果を提示 → ユーザー確認
  4. 確認済み情報のみで SKILL.md 生成
```

### 既存スキルの更新

```
ユーザー: 「プロジェクト構成が変わったからスキルを更新して」

Copilot:
  1. 既存スキルを読み込み
  2. 差分分析（新ディレクトリ、削除ファイル、パターン変更）
  3. SKILL.md を更新
  4. 変更箇所をレポート
```

