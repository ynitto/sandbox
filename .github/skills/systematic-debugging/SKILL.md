---
name: systematic-debugging
description: バグ、テスト失敗、予期しない動作に遭遇した際、修正を提案する前に使用する
---

# 体系的デバッグ

## 概要

場当たり的な修正は時間を浪費し、新たなバグを生む。安易なパッチは根本的な問題を隠す。

**基本原則:** 修正を試みる前に、必ず根本原因を特定せよ。症状の修正は失敗である。

**このプロセスの字面を破ることは、デバッグの精神を破ることである。**

## 鉄則

```
根本原因の調査なしに修正を行ってはならない
```

フェーズ1を完了していなければ、修正を提案してはならない。

## いつ使うか

あらゆる技術的問題に使用:
- テスト失敗
- 本番環境のバグ
- 予期しない動作
- パフォーマンス問題
- ビルド失敗
- 統合の問題

**特に以下の場合に使用:**
- 時間的プレッシャー下にあるとき（緊急時は推測に走りがち）
- 「ちょっとした修正」が明白に見えるとき
- すでに複数の修正を試したとき
- 前回の修正がうまくいかなかったとき
- 問題を完全に理解していないとき

**以下の場合もスキップしない:**
- 問題が単純に見える（単純なバグにも根本原因がある）
- 急いでいる（急ぐとやり直しが保証される）
- 上司が今すぐ直せと言っている（体系的アプローチは場当たり的より速い）

## 4つのフェーズ

各フェーズを完了してから次に進まなければならない。

### フェーズ1: 根本原因の調査

**いかなる修正を試みる前に:**

1. **エラーメッセージを注意深く読む**
   - エラーや警告を読み飛ばさない
   - 正確な解決策が含まれていることが多い
   - スタックトレースを最後まで読む
   - 行番号、ファイルパス、エラーコードを記録する

2. **一貫して再現する**
   - 確実にトリガーできるか？
   - 正確な手順は？
   - 毎回発生するか？
   - 再現できない場合 → データを収集する、推測しない

3. **最近の変更を確認する**
   - これを引き起こし得る変更は何か？
   - git diff、最近のコミット
   - 新しい依存関係、設定変更
   - 環境の違い

4. **マルチコンポーネントシステムでの証拠収集**

   **システムが複数のコンポーネントを持つ場合（CI → ビルド → 署名、API → サービス → データベース）:**

   **修正を提案する前に、診断用の計装を追加:**
   ```
   各コンポーネント境界について:
     - コンポーネントに入るデータをログ出力
     - コンポーネントから出るデータをログ出力
     - 環境/設定の伝播を検証
     - 各レイヤーの状態を確認

   一度実行して、どこで壊れるかを示す証拠を収集
   その後、証拠を分析して障害コンポーネントを特定
   その後、その特定コンポーネントを調査
   ```

   **例（多層システム）:**
   ```bash
   # レイヤー1: ワークフロー
   echo "=== ワークフローで利用可能なシークレット: ==="
   echo "IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}"

   # レイヤー2: ビルドスクリプト
   echo "=== ビルドスクリプトの環境変数: ==="
   env | grep IDENTITY || echo "IDENTITY が環境にない"

   # レイヤー3: 署名スクリプト
   echo "=== キーチェーンの状態: ==="
   security list-keychains
   security find-identity -v

   # レイヤー4: 実際の署名
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **これにより判明する:** どのレイヤーが失敗するか（シークレット → ワークフロー ✓、ワークフロー → ビルド ✗）

5. **データフローを追跡する**

   **エラーがコールスタックの深い位置にある場合:**

   完全な逆方向トレース技法は `references/root-cause-tracing.md` を参照。

   **簡易版:**
   - 不正な値はどこから発生するか？
   - 不正な値でこれを呼び出したのは何か？
   - ソースが見つかるまで遡り続ける
   - 症状ではなくソースで修正する

### フェーズ2: パターン分析

**修正する前にパターンを見つける:**

1. **動作する例を見つける**
   - 同じコードベースで類似の動作するコードを探す
   - 壊れているものに似ていて動作するものは何か？

2. **リファレンスと比較する**
   - パターンを実装する場合、リファレンス実装を完全に読む
   - 流し読みしない — 全行を読む
   - パターンを完全に理解してから適用する

3. **差異を特定する**
   - 動作するものと壊れているものの違いは何か？
   - どんなに小さくても全ての違いをリスト化する
   - 「それは関係ないはず」と決めつけない

4. **依存関係を理解する**
   - これに必要な他のコンポーネントは？
   - どんな設定、構成、環境が必要か？
   - どんな前提条件があるか？

### フェーズ3: 仮説とテスト

**科学的方法:**

1. **単一の仮説を立てる**
   - 明確に述べる:「Yという理由で、根本原因はXだと考える」
   - 書き留める
   - 曖昧ではなく具体的に

2. **最小限のテスト**
   - 仮説を検証するための最小限の変更を行う
   - 一度に一つの変数のみ
   - 複数のものを同時に修正しない

3. **続行前に検証する**
   - うまくいった？ → フェーズ4へ
   - うまくいかなかった？ → 新しい仮説を立てる
   - 上に追加の修正を重ねない

4. **わからないとき**
   - 「Xがわからない」と言う
   - 知っているふりをしない
   - 助けを求める
   - もっと調べる

### フェーズ4: 実装

**症状ではなく根本原因を修正する:**

1. **失敗するテストケースを作成する**
   - 最もシンプルな再現
   - 可能であれば自動テスト
   - フレームワークがなければワンオフのテストスクリプト
   - 修正前に必ず用意する

2. **単一の修正を実装する**
   - 特定された根本原因に対処
   - 一度に1つの変更のみ
   - 「ついでに」の改善はしない
   - リファクタリングをバンドルしない

3. **修正を検証する**
   - テストが通るか？
   - 他のテストが壊れていないか？
   - 問題は実際に解決したか？

4. **修正がうまくいかない場合**
   - 停止する
   - 数える: 何回修正を試したか？
   - 3回未満: フェーズ1に戻り、新しい情報で再分析
   - **3回以上: 停止してアーキテクチャを問い直す（下記ステップ5）**
   - アーキテクチャの議論なしに修正#4を試みない

5. **3回以上の修正が失敗した場合: アーキテクチャを問い直す**

   **アーキテクチャ問題を示すパターン:**
   - 各修正が異なる場所で新たな共有状態/結合/問題を明らかにする
   - 修正の実装に「大規模なリファクタリング」が必要
   - 各修正が別の場所で新たな症状を生む

   **立ち止まって根本を問い直す:**
   - このパターンは根本的に健全か？
   - 「惰性で続けている」だけではないか？
   - 症状の修正を続けるより、アーキテクチャをリファクタリングすべきか？

   **さらなる修正を試みる前に人間のパートナーと議論する**

   これは仮説の失敗ではなく、アーキテクチャの誤りである。

## 危険信号 — 停止してプロセスに従う

自分がこう考えていることに気づいたら:
- 「とりあえず修正して、後で調査する」
- 「Xを変えてみてうまくいくか試す」
- 「複数の変更を追加してテストを実行する」
- 「テストはスキップして、手動で確認する」
- 「たぶんXだろう、それを直そう」
- 「完全には理解していないが、これでうまくいくかも」
- 「パターンはXと言っているが、別のやり方で適用する」
- 「主な問題はこれだ:（調査なしに修正をリスト化）」
- データフローを追跡する前にソリューションを提案する
- **「もう一回修正を試みる」（すでに2回以上試した場合）**
- **各修正が異なる場所で新たな問題を明らかにする**

**これらすべてが意味すること: 停止。フェーズ1に戻る。**

**3回以上の修正が失敗した場合:** アーキテクチャを問い直す（フェーズ4.5参照）

## 人間のパートナーからの「間違っている」シグナル

**これらのリダイレクトに注意:**
- 「それは起きていないのでは？」 — 検証せずに仮定した
- 「それで分かるのか…？」 — 証拠収集を追加すべきだった
- 「推測をやめて」 — 理解なしに修正を提案している
- 「もっと深く考えて」 — 症状だけでなく根本を問え
- 「行き詰まった？」（苛立ち） — アプローチがうまくいっていない

**これらを見たら:** 停止。フェーズ1に戻る。

## よくある言い訳

| 言い訳 | 現実 |
|--------|------|
| 「問題は単純、プロセスは不要」 | 単純な問題にも根本原因がある。プロセスは単純なバグには速い。 |
| 「緊急、プロセスの時間がない」 | 体系的デバッグは推測と試行錯誤の繰り返しより速い。 |
| 「まずこれを試して、それから調査する」 | 最初の修正がパターンを決める。最初から正しくやる。 |
| 「修正が動くか確認してからテストを書く」 | テストされていない修正は定着しない。テストファーストで証明する。 |
| 「複数の修正を同時にやれば時間節約」 | 何が効いたか切り分けられない。新たなバグの原因になる。 |
| 「リファレンスが長すぎる、パターンを適応する」 | 部分的な理解はバグを保証する。完全に読む。 |
| 「問題が見えた、修正しよう」 | 症状が見える ≠ 根本原因を理解している。 |
| 「もう一回修正を試す」（2回以上失敗後） | 3回以上の失敗 = アーキテクチャの問題。パターンを問え、再修正するな。 |

## クイックリファレンス

| フェーズ | 主な活動 | 成功基準 |
|---------|---------|---------|
| **1. 根本原因** | エラーを読む、再現する、変更を確認、証拠を収集 | 何が、なぜを理解する |
| **2. パターン** | 動作する例を見つける、比較する | 差異を特定 |
| **3. 仮説** | 理論を立てる、最小限のテスト | 確認済みまたは新仮説 |
| **4. 実装** | テスト作成、修正、検証 | バグ解決、テスト通過 |

## プロセスで「根本原因なし」が判明した場合

体系的調査の結果、問題が環境依存、タイミング依存、または外部要因であると判明した場合:

1. プロセスは完了している
2. 調査した内容を文書化する
3. 適切な処理を実装する（リトライ、タイムアウト、エラーメッセージ）
4. 将来の調査のためにモニタリング/ロギングを追加する

**ただし:** 「根本原因なし」ケースの95%は、調査が不完全。

## 補助テクニック

これらのテクニックは体系的デバッグの一部であり、`references/` ディレクトリで利用可能:

- **`references/root-cause-tracing.md`** - コールスタックを逆方向にトレースして元のトリガーを見つける
- **`references/defense-in-depth.md`** - 根本原因発見後、複数レイヤーにバリデーションを追加
- **`references/condition-based-waiting.md`** - 任意のタイムアウトを条件ベースのポーリングに置き換える

**スクリプト（`scripts/` ディレクトリ）:**
- **`scripts/find-polluter.sh`** - テスト汚染者の二分探索スクリプト（Unix/macOS）
- **`scripts/find-polluter.ps1`** - 同上のPowerShell版（Windows）

**サンプルコード（`assets/` ディレクトリ）:**
- **`assets/condition-based-waiting-example.ts`** - 条件ベース待機のTypeScript実装例

## 実際の効果

デバッグセッションからの実績:
- 体系的アプローチ: 修正まで15〜30分
- 場当たり的修正: 2〜3時間の試行錯誤
- 初回修正成功率: 95% vs 40%
- 新たなバグの導入: ほぼゼロ vs 頻発

## 実行後フィードバック（必須）

> **scrum-master 経由の場合**: このセクションをスキップしてください。フィードバックはスプリント終了時に一括で収集されます。

スキルの手順を全て完了したら、ユーザーに確認する:

「systematic-debugging の実行はいかがでしたか？
 1. 問題なかった (ok)
 2. 改善点がある (needs-improvement)
 3. うまくいかなかった (broken)」

回答に応じて以下を実行する（git-skill-manager がない環境ではスキップ）:
```
python -c "import os,sys,subprocess; s=os.path.join(os.path.expanduser('~'),'.copilot','skills','git-skill-manager','scripts','record_feedback.py'); subprocess.run([sys.executable,s,'systematic-debugging','--verdict','<verdict>','--note','<note>']) if os.path.isfile(s) else None"
```

スクリプトの出力に「EVAL_RECOMMEND: promote」または「EVAL_RECOMMEND: refine」が含まれる場合は、
skill-evaluator サブエージェントを起動して評価・昇格フローを進める:
```
skill-evaluator スキルで systematic-debugging を評価する。
手順: .github/skills/skill-evaluator/SKILL.md を読んで手順に従ってください。
対象スキル: systematic-debugging
```
